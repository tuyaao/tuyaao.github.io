<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Hashtable&amp;HashMap的区别 by tuyaao</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Hashtable&amp;HashMap的区别</h1>
      <h2 class="project-tagline"></h2>
    </section>

    <section class="main-content">
      <h1>
<a id="先总结" class="anchor" href="#%E5%85%88%E6%80%BB%E7%BB%93" aria-hidden="true"><span class="octicon octicon-link"></span></a>先总结：</h1>

<p>Hashtable
注意1 方法是同步的
注意2 方法不允许value==null
注意3 方法调用了key的hashCode方法，如果key==null,会抛出空指针异常
HashMap<br>
注意1 键和值都是对象
注意2 方法是非同步的(但是需要的时候可以做同步，性能比较高)
注意3 方法允许key==null,但是只有一个
注意4 方法并没有对value进行任何调用，所以允许为null
Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差</p>

<h1>
<a id="我们先看2个类的定义" class="anchor" href="#%E6%88%91%E4%BB%AC%E5%85%88%E7%9C%8B2%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89" aria-hidden="true"><span class="octicon octicon-link"></span></a>我们先看2个类的定义</h1>

<p>public class Hashtable<br>
    extends Dictionary<br>
    implements Map, Cloneable, java.io.Serializable  </p>

<p>public class HashMap<br>
    extends AbstractMap<br>
    implements Map, Cloneable, Serializable</p>

<h3>
<a id="可见hashtable-继承自-dictiionary-而-hashmap继承自abstractmap" class="anchor" href="#%E5%8F%AF%E8%A7%81hashtable-%E7%BB%A7%E6%89%BF%E8%87%AA-dictiionary-%E8%80%8C-hashmap%E7%BB%A7%E6%89%BF%E8%87%AAabstractmap" aria-hidden="true"><span class="octicon octicon-link"></span></a>可见Hashtable 继承自 Dictiionary 而 HashMap继承自AbstractMap</h3>

<h1>
<a id="hashtable的put方法如下" class="anchor" href="#hashtable%E7%9A%84put%E6%96%B9%E6%B3%95%E5%A6%82%E4%B8%8B" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hashtable的put方法如下</h1>

<p>public synchronized V put(K key, V value) {  //###### 注意这里1<br>
  // Make sure the value is not null<br>
  if (value == null) { //###### 注意这里 2<br>
    throw new NullPointerException();<br>
  }<br>
  // Makes sure the key is not already in the hashtable.<br>
  Entry tab[] = table;<br>
  int hash = key.hashCode(); //###### 注意这里 3<br>
  int index = (hash &amp; 0x7FFFFFFF) % tab.length;<br>
  for (Entry e = tab[index]; e != null; e = e.next) {<br>
    if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {<br>
      V old = e.value;<br>
      e.value = value;<br>
      return old;<br>
    }<br>
  }<br>
  modCount++;<br>
  if (count &gt;= threshold) {<br>
    // Rehash the table if the threshold is exceeded<br>
    rehash();<br>
    tab = table;<br>
    index = (hash &amp; 0x7FFFFFFF) % tab.length;<br>
  }<br>
  // Creates the new entry.<br>
  Entry e = tab[index];<br>
  tab[index] = new Entry(hash, key, value, e);<br>
  count++;<br>
  return null;<br>
}  </p>

<h1>
<a id="hashmap的put方法如下" class="anchor" href="#hashmap%E7%9A%84put%E6%96%B9%E6%B3%95%E5%A6%82%E4%B8%8B" aria-hidden="true"><span class="octicon octicon-link"></span></a>HashMap的put方法如下</h1>

<p>public V put(K key, V value) { //###### 注意这里 1<br>
  if (key == null)  //###### 注意这里 2<br>
    return putForNullKey(value);<br>
  int hash = hash(key.hashCode());<br>
  int i = indexFor(hash, table.length);<br>
  for (Entry e = table[i]; e != null; e = e.next) {<br>
    Object k;<br>
    if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {<br>
      V oldValue = e.value;<br>
      e.value = value;<br>
      e.recordAccess(this);<br>
      return oldValue;<br>
    }<br>
  }<br>
  modCount++;<br>
  addEntry(hash, key, value, i);  //###### 注意这里<br>
  return null;<br>
}  </p>

<h3>
<a id="附hashtable容易被误解的部分" class="anchor" href="#%E9%99%84hashtable%E5%AE%B9%E6%98%93%E8%A2%AB%E8%AF%AF%E8%A7%A3%E7%9A%84%E9%83%A8%E5%88%86" aria-hidden="true"><span class="octicon octicon-link"></span></a>附：Hashtable容易被误解的部分</h3>

<p>hashmap 有以下这两个方法：
numbers.containsKey(a)
numbers.containsValue(value)、
hashtable 有一个contain()方法：
他不是判断是否存在关联的键，而是判断是否存在关键的值
继承于Map接口
contains（Object value）
测试此映射表中是否存在与指定值关联的键（如果此 Hashtable 将一个或多个键映射到此值，则返回 true）。
判断容器中是否存在值
但是contains并非和containsKey的功能一致而是和containsValue功能等同. 之所以说是等同原因是需要实现MAP中的containsValue:
public boolean containsValue(Object value) {
 return contains(value);
}</p>

      <footer class="site-footer">

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>

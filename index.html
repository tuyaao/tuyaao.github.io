<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>快排的时间复杂度  by tuyaao</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">快排的时间复杂度 </h1>
      <h2 class="project-tagline"></h2>
    </section>

    <section class="main-content">
      <h3>
<a id="1快速排序-时空复杂度" class="anchor" href="#1%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.快速排序-时空复杂度：</h3>

<p>快速排序每次将待排序数组分为两个部分，在理想状况下，每一次都将待排序数组划分成等长两个部分，则需要logn次划分。
而在最坏情况下，即数组已经有序或大致有序的情况下，每次划分只能减少一个元素，快速排序将不幸退化为冒泡排序，所以快速排序时间复杂度下界为O(nlogn)，最坏情况为O(n^2)。在实际应用中，快速排序的平均时间复杂度为O(nlogn)。
快速排序在对序列的操作过程中只需花费常数级的空间。空间复杂度S(1)。
但需要注意递归栈上需要花费最少logn最多n的空间。</p>

<h3>
<a id="2快速排序-随机化算法" class="anchor" href="#2%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%AE%97%E6%B3%95" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.快速排序-随机化算法：</h3>

<p>快速排序的实现需要消耗递归栈的空间，而大多数情况下都会通过使用系统递归栈来完成递归求解。在元素数量较大时，对系统栈的频繁存取会影响到排序的效率。
一种常见的办法是设置一个阈值，在每次递归求解中，如果元素总数不足这个阈值，则放弃快速排序，调用一个简单的排序过程完成该子序列的排序。这样的方法减少了对系统递归栈的频繁存取，节省了时间的消费。
一般的经验表明，阈值取一个较小的值，排序算法采用选择、插入等紧凑、简洁的排序。一个可以参考的具体方案：阈值T=10，排序算法用选择排序。
阈值不要太大，否则省下的存取系统栈的时间，将会被简单排序算法较多的时间花费所抵消。
另一个可以参考的方法，是自行建栈模拟递归过程。但实际经验表明，收效明显不如设置阈值。</p>

<h3>
<a id="3快速排序的最坏情况基于每次划分对主元的选择" class="anchor" href="#3%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5%E5%9F%BA%E4%BA%8E%E6%AF%8F%E6%AC%A1%E5%88%92%E5%88%86%E5%AF%B9%E4%B8%BB%E5%85%83%E7%9A%84%E9%80%89%E6%8B%A9" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.快速排序的最坏情况基于每次划分对主元的选择。</h3>

<p>基本的快速排序选取第一个元素作为主元。这样在数组已经有序的情况下，每次划分将得到最坏的结果。一种比较常见的优化方法是随机化算法，即随机选取一个元素作为主元。这种情况下虽然最坏情况仍然是O(n^2)，但最坏情况不再依赖于输入数据，而是由于随机函数取值不佳。实际上，随机化快速排序得到理论最坏情况的可能性仅为1/(2^n)。所以随机化快速排序可以对于绝大多数输入数据达到O(nlogn)的期望时间复杂度。一位前辈做出了一个精辟的总结：“随机化快速排序可以满足一个人一辈子的人品需求。”
随机化快速排序的唯一缺点在于，一旦输入数据中有很多的相同数据，随机化的效果将直接减弱。对于极限情况，即对于n个相同的数排序，随机化快速排序的时间复杂度将毫无疑问的降低到O(n^2)。解决方法是用一种方法进行扫描，使没有交换的情况下主元保留在原位置。</p>

      <footer class="site-footer">

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>

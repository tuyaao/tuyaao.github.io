{"name":"Tuyaao.GitHub.io","tagline":"Integer 的比较","body":"# 对于\"==\"\r\n## 都知道如果是对象，那么比较栈中的对象地址,如果是基本值，则在栈中直接获取值比较，那么对于\r\n   Integer e = 1;\r\n   看一个例子：\r\n public class Test {\r\n     public static void main(String[] args) {\r\n         Integer a = 10;\r\n         Integer b = 10;\r\n        System.out.println(\"a==b : \" + String.valueOf(a==b));\r\n        System.out.println(\"a.equals(b) : \" + String.valueOf(a.equals(b)));\r\n    }\r\n}\r\n\r\n运行一下，在控制台得到的结果是这样的\r\na==b : true\r\na.equals(b) : true\r\n\r\n当是当我们变换一下值\r\n public class Test {\r\n     public static void main(String[] args) {\r\n         Integer a = 1000;\r\n         Integer b = 1000;\r\n        System.out.println(\"a==b : \" + String.valueOf(a==b));\r\n        System.out.println(\"a.equals(b) : \" + String.valueOf(a.equals(b)));\r\n    }\r\n}\r\n\r\n运行一下，控制台的结果又是\r\na==b : false\r\na.equals(b) : true\r\n\r\n这是什么原因呢？我当时也有点犯糊涂。有点冲动就直接开源码看了。\r\n实际上在我们用Integer a = 数字；来赋值的时候Integer这个类是调用的public static Integer valueOf(int i)这个方法。\r\n\r\npublic static Integer valueOf(int i) {\r\n        if(i >= -128 && i <= IntegerCache.high)\r\n            return IntegerCache.cache[i + 128];\r\n        else\r\n            return new Integer(i);\r\n    }\r\n\r\n我们来看看ValueOf(int i)的代码，可以发现他对传入参数i做了一个if判断。在-128<=i<=127的时候是直接用的int原始数据类型，而超出了这个范围则是new了一个对象。我们知道\"==\"符号在比较对象的时候是比较的内存地址，而对于原始数据类型是直接比对的数据值。那么这个问题就解决了。\r\n至于为什么用int型的时候值会在-128<=i<=127范围呢呢?我们知道八位二进制的表示的范围正好就是-128到127。大概就是因为这吧。\r\n\r\n所以有时是相等的有时是不等的\r\n所以：new 一定是开辟新的内存，直接赋值则不一定开辟新的内存\r\n\r\ninteger好像不能直接比较大小，要转化为int ","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}